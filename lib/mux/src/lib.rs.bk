extern crate byteorder;
extern crate sharedbuffer;

use sharedbuffer::SharedReadBuffer;

use std::io::{Seek, Read, SeekFrom};

use byteorder::{ReadBytesExt, BigEndian};

pub type DecodeResult<T> = Result<T,DecodeFail>;

#[derive(Debug)]
pub enum DecodeFail {
  Error(std::io::Error),
  Incomplete(Option<usize>)
}

pub struct Tag {
  pub end: bool,
  pub id: u32
}

fn read_tag<T: Read>(r: &mut T) -> byteorder::Result<Tag> {
  let mut bts = [0;3];
  let _ = try!(r.read(&mut bts));

  let id = (!(1 << 23)) &  // clear the last bit
            ((bts[0] as u32) << 16 | 
             (bts[1] as u32) <<  8 | 
             (bts[2] as u32));

  Ok(Tag { end: (1 << 7) & bts[0] != 0, id: id })
}

struct MessageFrame {
    tpe:   i8,
    tag:  Tag,
    bytes: SharedReadBuffer
}

pub enum Message {
    Tdispatch {
        contexts: Vec<(Vec<u8>, Vec<u8>)>,
        dst:      String,
        dtab:     Vec<(Vec<u8>, Vec<u8>)>,
        req:      Vec<u8>
    }
}



pub fn decode_message_frame(input: &mut SharedReadBuffer) -> DecodeResult<Message> {
  if input.remaining() < 8 {
    return Err(DecodeFail::Incomplete(None));
  }

  // shoudln't fail, we already ensured the bytes where available
  let size = input.read_i32::<BigEndian>().unwrap();

  if (size as usize) > input.remaining() - 4 {
    input.seek(SeekFrom::Current(-4)).unwrap();
    return Err(DecodeFail::Incomplete(None));
  }

  let buff_size = size - 4;

  let tpe = input.read_i8().unwrap();
  let tag = read_tag(input).unwrap();
  
  // this shouldn't fail
  let msg_buff = input.consume_slice(buff_size as usize).unwrap();

  debug_assert_eq!(msg_buff.remaining(), buff_size as usize);

  let frame = MessageFrame {
    tpe: tpe,
    tag: tag,
    bytes: msg_buff
  };

  panic!("Not complete.")
}

#[test]
fn it_works() {
  let a = Some(4);
  if let Some(4) = a {
    println!("It is the number 4!");
  }
}

